{"version":3,"sources":["popper.js"],"names":["global","factory","exports","module","define","amd","Popper","getOffsetParent","element","offsetParent","nodeName","window","document","documentElement","getStyleComputedProperty","property","nodeType","css","getComputedStyle","getParentNode","parentNode","host","getScrollParent","indexOf","body","overflow","overflowX","overflowY","test","getWindowSizes","html","height","Math","max","scrollHeight","offsetHeight","clientHeight","width","scrollWidth","offsetWidth","clientWidth","getOffsetRect","elementRect","left","top","offsetLeft","offsetTop","right","bottom","isFixed","getPosition","container","isParentFixed","getBoundingClientRect","isIE10","navigator","appVersion","rect","err","result","scrollTop","scrollLeft","horizScrollbar","vertScrollbar","styles","Number","borderLeftWidth","split","borderRightWidth","borderTopWidth","borderBottomWidth","getScroll","side","upperSide","scrollingElement","getOffsetRectRelativeToCustomParent","parent","fixed","transformed","scrollParent","parentRect","contains","getTotalScroll","scroll","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","computeAutoPlacement","placement","refRect","sides","computedPlacement","Object","keys","sort","a","b","variation","nativeHints","isNative","fn","some","hint","toString","longerTimeoutBrowsers","timeoutDuration","i","length","userAgent","microtaskDebounce","scheduled","elem","createElement","observer","MutationObserver","observe","attributes","setAttribute","taskDebounce","setTimeout","supportsNativeMutationObserver","debounce","findIndex$1","arr","check","Array","prototype","find","filter","findIndex","prop","value","cur","match","obj","_extends","assign","target","arguments","source","key","hasOwnProperty","call","getClientRect","popperOffsets","getOuterSizes","x","parseFloat","marginTop","marginBottom","y","marginLeft","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","state","referenceOffsets","popperRect","position","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","reference","isParentTransformed","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","prefix","toCheck","style","isFunction","functionToCheck","getType","isModifierEnabled","modifiers","modifierName","name","enabled","isModifierRequired","requestingName","requestedName","requesting","modifier","order","isNumeric","n","isNaN","isFinite","isTransformed","removeEventListeners","removeEventListener","updateBound","scrollElement","eventsEnabled","runModifiers","data","ends","modifiersToRun","undefined","forEach","function","setAttributes","removeAttribute","setStyles","unit","setupEventListeners","options","addEventListener","passive","Utils","applyStyle","offsets","round","prefixedProperty","gpuAcceleration","willChange","instance","arrow","arrowElement","applyStyleOnLoad","modifierOptions","console","warn","querySelector","isVertical","len","altSide","opSide","arrowElementSize","center","sideValue","min","getOppositeVariation","flip","flipped","originalPlacement","placementOpposite","flipOrder","behavior","step","index","refOffsets","overlapsRef","floor","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","offset","map","useHeight","referenceRect","size","innerHeight","innerWidth","preventOverflow","priority","shouldOverflowBoundary","direction","overflowDirection","escapeWithReference","isSameAxis","aDirection","bDirection","shift","basePlacement","shiftvariation","shiftOffsets","start","end","axis","hide","bound","inner","subtractLength","onLoad","DEFAULTS","onCreate","onUpdate","constructor","scheduleUpdate","requestAnimationFrame","update","bind","Defaults","isDestroyed","isCreated","jquery","defaultConfig","userConfig","push","enableEventListeners","destroy","disableEventListeners","removeOnDestroy","removeChild","cancelAnimationFrame","placements"],"mappings":"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","file":"popper.js","sourcesContent":["/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.0.4\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */    \n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.Popper = factory());\n  }(this, (function () { 'use strict';\n  \n  /**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n  function getOffsetParent(element) {\n      // NOTE: 1 DOM access here\n      const offsetParent = element.offsetParent;\n      const nodeName = offsetParent && offsetParent.nodeName;\n  \n      if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n          return window.document.documentElement;\n      }\n  \n      return offsetParent;\n  }\n  \n  /**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */\n  function getStyleComputedProperty(element, property) {\n      if (element.nodeType !== 1) {\n          return [];\n      }\n      // NOTE: 1 DOM access here\n      const css = window.getComputedStyle(element, null);\n      return property ? css[property] : css;\n  }\n  \n  /**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */\n  function getParentNode(element) {\n      if (element.nodeName === 'HTML') {\n          return element;\n      }\n      return element.parentNode || element.host;\n  }\n  \n  /**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n  function getScrollParent(element) {\n      // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n      if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n          return window.document.body;\n      }\n  \n      // Firefox want us to check `-x` and `-y` variations as well\n      const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n      if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n          return element;\n      }\n  \n      return getScrollParent(getParentNode(element));\n  }\n  \n  function getWindowSizes() {\n      const body = window.document.body;\n      const html = window.document.documentElement;\n      return {\n          height: Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight),\n          width: Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth)\n      };\n  }\n  \n  /**\n   * Get the position of the given element, relative to its offset parent\n   * @method\n   * @memberof Popper.Utils\n   * @param {Element} element\n   * @return {Object} position - Coordinates of the element and its `scrollTop`\n   */\n  function getOffsetRect(element) {\n      let elementRect;\n      if (element.nodeName === 'HTML') {\n          const { width, height } = getWindowSizes();\n          elementRect = {\n              width,\n              height,\n              left: 0,\n              top: 0\n          };\n      } else {\n          elementRect = {\n              width: element.offsetWidth,\n              height: element.offsetHeight,\n              left: element.offsetLeft,\n              top: element.offsetTop\n          };\n      }\n  \n      elementRect.right = elementRect.left + elementRect.width;\n      elementRect.bottom = elementRect.top + elementRect.height;\n  \n      // position\n      return elementRect;\n  }\n  \n  /**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */\n  function isFixed(element) {\n      const nodeName = element.nodeName;\n      if (nodeName === 'BODY' || nodeName === 'HTML') {\n          return false;\n      }\n      if (getStyleComputedProperty(element, 'position') === 'fixed') {\n          return true;\n      }\n      return isFixed(getParentNode(element));\n  }\n  \n  /**\n   * Helper used to get the position which will be applied to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param config {HTMLElement} popper element\n   * @returns {HTMLElement} reference element\n   */\n  function getPosition(element) {\n    const container = getOffsetParent(element);\n  \n    // Decide if the popper will be fixed\n    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n    const isParentFixed = isFixed(container);\n    return isParentFixed ? 'fixed' : 'absolute';\n  }\n  \n  /**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */\n  function getBoundingClientRect(element) {\n      const isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;\n      let rect;\n  \n      // IE10 10 FIX: Please, don't ask, the element isn't\n      // considered in DOM in some circumstances...\n      // This isn't reproducible in IE10 compatibility mode of IE11\n      if (isIE10) {\n          try {\n              rect = element.getBoundingClientRect();\n          } catch (err) {\n              rect = {};\n          }\n      } else {\n          rect = element.getBoundingClientRect();\n      }\n  \n      const result = {\n          left: rect.left,\n          top: rect.top,\n          right: rect.right,\n          bottom: rect.bottom,\n          width: rect.right - rect.left,\n          height: rect.bottom - rect.top\n      };\n  \n      // IE10 FIX: `getBoundingClientRect`, when executed on `documentElement`\n      // will not take in account the `scrollTop` and `scrollLeft`\n      if (element.nodeName === 'HTML' && isIE10) {\n          const { scrollTop, scrollLeft } = window.document.documentElement;\n          result.top -= scrollTop;\n          result.bottom -= scrollTop;\n          result.left -= scrollLeft;\n          result.right -= scrollLeft;\n      }\n  \n      // subtract scrollbar size from sizes\n      let horizScrollbar = rect.width - (element.clientWidth || rect.right - rect.left);\n      let vertScrollbar = rect.height - (element.clientHeight || rect.bottom - rect.top);\n  \n      // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n      // we make this check conditional for performance reasons\n      if (horizScrollbar || vertScrollbar) {\n          const styles = getStyleComputedProperty(element);\n          horizScrollbar -= Number(styles.borderLeftWidth.split('px')[0]) + Number(styles.borderRightWidth.split('px')[0]);\n          vertScrollbar -= Number(styles.borderTopWidth.split('px')[0]) + Number(styles.borderBottomWidth.split('px')[0]);\n      }\n  \n      result.right -= horizScrollbar;\n      result.width -= horizScrollbar;\n      result.bottom -= vertScrollbar;\n      result.height -= vertScrollbar;\n  \n      return result;\n  }\n  \n  function getScroll(element, side = 'top') {\n      const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n      const nodeName = element.nodeName;\n  \n      if (nodeName === 'BODY' || nodeName === 'HTML') {\n          const html = window.document.documentElement;\n          const scrollingElement = window.document.scrollingElement || html;\n          return scrollingElement[upperSide];\n      }\n  \n      return element[upperSide];\n  }\n  \n  /**\n   * Given an element and one of its parents, return the offset\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @param {HTMLElement} parent\n   * @return {Object} rect\n   */\n  function getOffsetRectRelativeToCustomParent(element, parent, fixed = false, transformed = false) {\n      const scrollParent = getScrollParent(parent);\n      const elementRect = getBoundingClientRect(element);\n      const parentRect = getBoundingClientRect(parent);\n  \n      const rect = {\n          top: elementRect.top - parentRect.top,\n          left: elementRect.left - parentRect.left,\n          bottom: elementRect.top - parentRect.top + elementRect.height,\n          right: elementRect.left - parentRect.left + elementRect.width,\n          width: elementRect.width,\n          height: elementRect.height\n      };\n  \n      if (fixed && !transformed) {\n          const scrollTop = getScroll(scrollParent, 'top');\n          const scrollLeft = getScroll(scrollParent, 'left');\n          rect.top -= scrollTop;\n          rect.bottom -= scrollTop;\n          rect.left -= scrollLeft;\n          rect.right -= scrollLeft;\n      }\n      // When a popper doesn't have any positioned or scrollable parents, `offsetParent.contains(scrollParent)`\n      // will return a \"false positive\". This is happening because `getOffsetParent` returns `html` node,\n      // and `scrollParent` is the `body` node. Hence the additional check.\n      else if (getOffsetParent(element).contains(scrollParent) && scrollParent.nodeName !== 'BODY') {\n              const scrollTop = getScroll(parent, 'top');\n              const scrollLeft = getScroll(parent, 'left');\n              rect.top += scrollTop;\n              rect.bottom += scrollTop;\n              rect.left += scrollLeft;\n              rect.right += scrollLeft;\n          }\n  \n      // subtract borderTopWidth and borderTopWidth from final result\n      const styles = getStyleComputedProperty(parent);\n      const borderTopWidth = Number(styles.borderTopWidth.split('px')[0]);\n      const borderLeftWidth = Number(styles.borderLeftWidth.split('px')[0]);\n  \n      rect.top -= borderTopWidth;\n      rect.bottom -= borderTopWidth;\n      rect.left -= borderLeftWidth;\n      rect.right -= borderLeftWidth;\n  \n      return rect;\n  }\n  \n  function getTotalScroll(element, side = 'top') {\n      const scrollParent = getScrollParent(element);\n      const scroll = getScroll(scrollParent, side);\n  \n      if (['BODY', 'HTML'].indexOf(scrollParent.nodeName) === -1) {\n          return scroll + getTotalScroll(getParentNode(scrollParent), side);\n      }\n      return scroll;\n  }\n  \n  /**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n   * @param {Number} padding - Boundaries padding\n   * @param {Element} boundariesElement - Element used to define the boundaries\n   * @returns {Object} Coordinates of the boundaries\n   */\n  function getBoundaries(popper, padding, boundariesElement) {\n      // NOTE: 1 DOM access here\n      let boundaries = { top: 0, left: 0 };\n      const offsetParent = getOffsetParent(popper);\n  \n      // Handle viewport case\n      if (boundariesElement === 'viewport') {\n          const { left, top } = getOffsetRect(offsetParent);\n          const { clientWidth: width, clientHeight: height } = window.document.documentElement;\n  \n          if (getPosition(popper) === 'fixed') {\n              boundaries.right = width;\n              boundaries.bottom = height;\n          } else {\n              const scrollLeft = getTotalScroll(popper, 'left');\n              const scrollTop = getTotalScroll(popper, 'top');\n  \n              boundaries = {\n                  top: 0 - top,\n                  right: width - left + scrollLeft,\n                  bottom: height - top + scrollTop,\n                  left: 0 - left\n              };\n          }\n      }\n      // Handle other cases based on DOM element used as boundaries\n      else {\n              let boundariesNode;\n              if (boundariesElement === 'scrollParent') {\n                  boundariesNode = getScrollParent(getParentNode(popper));\n              } else if (boundariesElement === 'window') {\n                  boundariesNode = window.document.body;\n              } else {\n                  boundariesNode = boundariesElement;\n              }\n  \n              // In case of BODY, we need a different computation\n              if (boundariesNode.nodeName === 'BODY') {\n                  const { height, width } = getWindowSizes();\n                  boundaries.right = width;\n                  boundaries.bottom = height;\n              }\n              // for all the other DOM elements, this one is good\n              else {\n                      boundaries = getOffsetRectRelativeToCustomParent(boundariesNode, offsetParent, isFixed(popper));\n                  }\n          }\n  \n      // Add paddings\n      boundaries.left += padding;\n      boundaries.top += padding;\n      boundaries.right -= padding;\n      boundaries.bottom -= padding;\n  \n      return boundaries;\n  }\n  \n  /**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeAutoPlacement(placement, refRect, popper) {\n      if (placement.indexOf('auto') === -1) {\n          return placement;\n      }\n  \n      const boundaries = getBoundaries(popper, 0, 'scrollParent');\n  \n      const sides = {\n          top: refRect.top - boundaries.top,\n          right: boundaries.right - refRect.right,\n          bottom: boundaries.bottom - refRect.bottom,\n          left: refRect.left - boundaries.left\n      };\n  \n      const computedPlacement = Object.keys(sides).sort((a, b) => sides[b] - sides[a])[0];\n      const variation = placement.split('-')[1];\n  \n      return computedPlacement + (variation ? `-${ variation }` : '');\n  }\n  \n  const nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n  ];\n  \n  /**\n   * Determine if a function is implemented natively (as opposed to a polyfill).\n   * @argument {Function | undefined} fn the function to check\n   * @returns {boolean}\n   */\n  var isNative = (fn => nativeHints.some(hint => (fn || '').toString().indexOf(hint) > -1));\n  \n  const longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  let timeoutDuration = 0;\n  for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n      if (navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n          timeoutDuration = 1;\n          break;\n      }\n  }\n  \n  function microtaskDebounce(fn) {\n      let scheduled = false;\n      let i = 0;\n      let elem = document.createElement('span');\n  \n      // MutationObserver provides a mechanism for scheduling microtasks, which\n      // are scheduled *before* the next task. This gives us a way to debounce\n      // a function but ensure it's called *before* the next paint.\n      const observer = new MutationObserver(() => {\n          fn();\n          scheduled = false;\n      });\n  \n      observer.observe(elem, { attributes: true });\n  \n      return () => {\n          if (!scheduled) {\n              scheduled = true;\n              elem.setAttribute('x-index', i);\n              i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8\n          }\n      };\n  }\n  \n  function taskDebounce(fn) {\n      let scheduled = false;\n      return () => {\n          if (!scheduled) {\n              scheduled = true;\n              setTimeout(() => {\n                  scheduled = false;\n                  fn();\n              }, timeoutDuration);\n          }\n      };\n  }\n  \n  // It's common for MutationObserver polyfills to be seen in the wild, however\n  // these rely on Mutation Events which only occur when an element is connected\n  // to the DOM. The algorithm used in this module does not use a connected element,\n  // and so we must ensure that a *native* MutationObserver is available.\n  const supportsNativeMutationObserver = isNative(window.MutationObserver);\n  \n  /**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */\n  var debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n  \n  /**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function findIndex$1(arr, check) {\n      // use native find if supported\n      if (Array.prototype.find) {\n          return arr.find(check);\n      }\n  \n      // use `filter` to obtain the same behavior of `find`\n      return arr.filter(check)[0];\n  }\n  \n  /**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function findIndex(arr, prop, value) {\n      // use native findIndex if supported\n      if (Array.prototype.findIndex) {\n          return arr.findIndex(cur => cur[prop] === value);\n      }\n  \n      // use `find` + `indexOf` if `findIndex` isn't supported\n      const match = findIndex$1(arr, obj => obj[prop] === value);\n      return arr.indexOf(match);\n  }\n  \n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n  \n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n  \n    return target;\n  };\n  \n  /**\n   * Given the popper offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} popperOffsets\n   * @returns {Object} ClientRect like output\n   */\n  function getClientRect(popperOffsets) {\n      return _extends({}, popperOffsets, {\n          right: popperOffsets.left + popperOffsets.width,\n          bottom: popperOffsets.top + popperOffsets.height\n      });\n  }\n  \n  /**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */\n  function getOuterSizes(element) {\n      const styles = window.getComputedStyle(element);\n      const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n      const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n      const result = {\n          width: element.offsetWidth + y,\n          height: element.offsetHeight + x\n      };\n      return result;\n  }\n  \n  /**\n   * Get the opposite placement of the given one/\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */\n  function getOppositePlacement(placement) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n  }\n  \n  /**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n  function getPopperOffsets(state, popper, referenceOffsets, placement) {\n      placement = placement.split('-')[0];\n  \n      // Get popper node sizes\n      const popperRect = getOuterSizes(popper);\n  \n      // Add position, width and height to our offsets object\n      const popperOffsets = {\n          position: state.position,\n          width: popperRect.width,\n          height: popperRect.height\n      };\n  \n      // depending by the popper placement we have to compute its offsets slightly differently\n      const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n      const mainSide = isHoriz ? 'top' : 'left';\n      const secondarySide = isHoriz ? 'left' : 'top';\n      const measurement = isHoriz ? 'height' : 'width';\n      const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  \n      popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n      if (placement === secondarySide) {\n          popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n      } else {\n          popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n      }\n  \n      return popperOffsets;\n  }\n  \n  /**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n  function getReferenceOffsets(state, popper, reference) {\n    const isParentFixed = state.position === 'fixed';\n    const isParentTransformed = state.isParentTransformed;\n    const offsetParent = getOffsetParent(isParentFixed && isParentTransformed ? reference : popper);\n  \n    return getOffsetRectRelativeToCustomParent(reference, offsetParent, isParentFixed, isParentTransformed);\n  }\n  \n  /**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase)\n   */\n  function getSupportedPropertyName(property) {\n      const prefixes = [false, 'ms', 'webkit', 'moz', 'o'];\n      const upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n  \n      for (let i = 0; i < prefixes.length - 1; i++) {\n          const prefix = prefixes[i];\n          const toCheck = prefix ? `${ prefix }${ upperProp }` : property;\n          if (typeof window.document.body.style[toCheck] !== 'undefined') {\n              return toCheck;\n          }\n      }\n      return null;\n  }\n  \n  /**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to check\n   * @returns {Boolean} answer to: is a function?\n   */\n  function isFunction(functionToCheck) {\n    const getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n  \n  /**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */\n  function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(({ name, enabled }) => enabled && name === modifierName);\n  }\n  \n  /**\n   * Helper used to know if the given modifier depends from another one.\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */\n  function isModifierRequired(modifiers, requestingName, requestedName) {\n    const requesting = findIndex$1(modifiers, ({ name }) => name === requestingName);\n  \n    return !!requesting && modifiers.some(modifier => {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n  }\n  \n  /**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */\n  function isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n  }\n  \n  /**\n   * Check if the given element has transforms applied to itself or a parent\n   * @method\n   * @memberof Popper.Utils\n   * @param  {Element} element\n   * @return {Boolean} answer to \"isTransformed?\"\n   */\n  function isTransformed(element) {\n      if (element.nodeName === 'BODY') {\n          return false;\n      }\n      if (getStyleComputedProperty(element, 'transform') !== 'none') {\n          return true;\n      }\n      return getParentNode(element) ? isTransformed(getParentNode(element)) : element;\n  }\n  \n  /**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function removeEventListeners(reference, state) {\n      // NOTE: 1 DOM access here\n      window.removeEventListener('resize', state.updateBound);\n      if (state.scrollElement) {\n          state.scrollElement.removeEventListener('scroll', state.updateBound);\n      }\n      state.updateBound = null;\n      state.scrollElement = null;\n      state.eventsEnabled = false;\n      return state;\n  }\n  \n  /**\n   * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} data\n   * @param {Array} modifiers\n   * @param {Function} ends\n   */\n  function runModifiers(modifiers, data, ends) {\n      const modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n  \n      modifiersToRun.forEach(modifier => {\n          if (modifier.enabled && isFunction(modifier.function)) {\n              data = modifier.function(data, modifier);\n          }\n      });\n  \n      return data;\n  }\n  \n  /**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n   */\n  function setAttributes(element, attributes) {\n      Object.keys(attributes).forEach(function (prop) {\n          const value = attributes[prop];\n          if (value !== false) {\n              element.setAttribute(prop, attributes[prop]);\n          } else {\n              element.removeAttribute(prop);\n          }\n      });\n  }\n  \n  /**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n   */\n  function setStyles(element, styles) {\n      Object.keys(styles).forEach(prop => {\n          let unit = '';\n          // add unit if the value is numeric and is one of the following\n          if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n              unit = 'px';\n          }\n          element.style[prop] = styles[prop] + unit;\n      });\n  }\n  \n  /**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function setupEventListeners(reference, options, state, updateBound) {\n      // NOTE: 1 DOM access here\n      state.updateBound = updateBound;\n      window.addEventListener('resize', state.updateBound, { passive: true });\n      let target = getScrollParent(reference);\n      if (target.nodeName === 'BODY') {\n          target = window;\n      }\n      target.addEventListener('scroll', state.updateBound, { passive: true });\n      state.scrollElement = target;\n      state.eventsEnabled = true;\n  \n      return state;\n  }\n  \n  /** @namespace Popper.Utils */\n  var Utils = {\n      computeAutoPlacement,\n      debounce,\n      findIndex,\n      getBoundaries,\n      getBoundingClientRect,\n      getClientRect,\n      getOffsetParent,\n      getOffsetRect,\n      getOffsetRectRelativeToCustomParent,\n      getOuterSizes,\n      getParentNode,\n      getPopperOffsets,\n      getPosition,\n      getReferenceOffsets,\n      getScroll,\n      getScrollParent,\n      getStyleComputedProperty,\n      getSupportedPropertyName,\n      getTotalScroll,\n      getWindowSizes,\n      isFixed,\n      isFunction,\n      isModifierEnabled,\n      isModifierRequired,\n      isNative,\n      isNumeric,\n      isTransformed,\n      removeEventListeners,\n      runModifiers,\n      setAttributes,\n      setStyles,\n      setupEventListeners\n  };\n  \n  /**\n   * Apply the computed styles to the popper element\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */\n  function applyStyle(data, options) {\n      // apply the final offsets to the popper\n      // NOTE: 1 DOM access here\n      const styles = {\n          position: data.offsets.popper.position\n      };\n  \n      const attributes = {\n          'x-placement': data.placement\n      };\n  \n      // round top and left to avoid blurry text\n      const left = Math.round(data.offsets.popper.left);\n      const top = Math.round(data.offsets.popper.top);\n  \n      // if gpuAcceleration is set to true and transform is supported,\n      //  we use `translate3d` to apply the position to the popper we\n      // automatically use the supported prefixed version if needed\n      const prefixedProperty = getSupportedPropertyName('transform');\n      if (options.gpuAcceleration && prefixedProperty) {\n          styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n          styles.top = 0;\n          styles.left = 0;\n          styles.willChange = 'transform';\n      }\n      // othwerise, we use the standard `left` and `top` properties\n      else {\n              styles.left = left;\n              styles.top = top;\n              styles.willChange = 'top, left';\n          }\n  \n      // any property present in `data.styles` will be applied to the popper,\n      // in this way we can make the 3rd party modifiers add custom styles to it\n      // Be aware, modifiers could override the properties defined in the previous\n      // lines of this modifier!\n      setStyles(data.instance.popper, _extends({}, styles, data.styles));\n  \n      // any property present in `data.attributes` will be applied to the popper,\n      // they will be set as HTML attributes of the element\n      setAttributes(data.instance.popper, _extends({}, attributes, data.attributes));\n  \n      // if the arrow style has been computed, apply the arrow style\n      if (data.offsets.arrow) {\n          setStyles(data.arrowElement, data.offsets.arrow);\n      }\n  \n      return data;\n  }\n  \n  /**\n   * Set the x-placement attribute before everything else because it could be used to add margins to the popper\n   * margins needs to be calculated to get the correct popper offsets\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Popper.js options\n   */\n  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n      // compute reference element offsets\n      const referenceOffsets = getReferenceOffsets(state, popper, reference);\n  \n      // compute auto placement, store placement inside the data object,\n      // modifiers will be able to edit `placement` if needed\n      // and refer to originalPlacement to know the original value\n      options.placement = computeAutoPlacement(options.placement, referenceOffsets, popper);\n  \n      popper.setAttribute('x-placement', options.placement);\n      return options;\n  }\n  \n  /**\n   * Modifier used to move the arrowElements on the edge of the popper to make sure them are always between the popper and the reference element\n   * It will use the CSS outer size of the arrowElement element to know how many pixels of conjuction are needed\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function arrow(data, options) {\n      // arrow depends on keepTogether in order to work\n      if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n          console.warn('WARNING: `keepTogether` modifier is required by arrow modifier in order to work, be sure to include it before `arrow`!');\n          return data;\n      }\n  \n      let arrowElement = options.element;\n  \n      // if arrowElement is a string, suppose it's a CSS selector\n      if (typeof arrowElement === 'string') {\n          arrowElement = data.instance.popper.querySelector(arrowElement);\n  \n          // if arrowElement is not found, don't run the modifier\n          if (!arrowElement) {\n              return data;\n          }\n      } else {\n          // if the arrowElement isn't a query selector we must check that the\n          // provided DOM node is child of its popper node\n          if (!data.instance.popper.contains(arrowElement)) {\n              console.warn('WARNING: `arrow.element` must be child of its popper element!');\n              return data;\n          }\n      }\n  \n      const placement = data.placement.split('-')[0];\n      const popper = getClientRect(data.offsets.popper);\n      const reference = data.offsets.reference;\n      const isVertical = ['left', 'right'].indexOf(placement) !== -1;\n  \n      const len = isVertical ? 'height' : 'width';\n      const side = isVertical ? 'top' : 'left';\n      const altSide = isVertical ? 'left' : 'top';\n      const opSide = isVertical ? 'bottom' : 'right';\n      const arrowElementSize = getOuterSizes(arrowElement)[len];\n  \n      //\n      // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n      //\n  \n      // top/left side\n      if (reference[opSide] - arrowElementSize < popper[side]) {\n          data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n      }\n      // bottom/right side\n      if (reference[side] + arrowElementSize > popper[opSide]) {\n          data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n      }\n  \n      // compute center of the popper\n      const center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n  \n      // Compute the sideValue using the updated popper offsets\n      let sideValue = center - getClientRect(data.offsets.popper)[side];\n  \n      // prevent arrowElement from being placed not contiguously to its popper\n      sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n  \n      data.arrowElement = arrowElement;\n      data.offsets.arrow = {};\n      data.offsets.arrow[side] = sideValue;\n      data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node\n  \n      return data;\n  }\n  \n  /**\n   * Get the opposite placement variation of the given one/\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */\n  function getOppositeVariation(variation) {\n      if (variation === 'end') {\n          return 'start';\n      } else if (variation === 'start') {\n          return 'end';\n      }\n      return variation;\n  }\n  \n  /**\n   * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function flip(data, options) {\n      // if `inner` modifier is enabled, we can't use the `flip` modifier\n      if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n          return data;\n      }\n  \n      if (data.flipped && data.placement === data.originalPlacement) {\n          // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n          return data;\n      }\n  \n      const boundaries = getBoundaries(data.instance.popper, options.padding, options.boundariesElement);\n  \n      let placement = data.placement.split('-')[0];\n      let placementOpposite = getOppositePlacement(placement);\n      let variation = data.placement.split('-')[1] || '';\n  \n      let flipOrder = [];\n  \n      if (options.behavior === 'flip') {\n          flipOrder = [placement, placementOpposite];\n      } else {\n          flipOrder = options.behavior;\n      }\n  \n      flipOrder.forEach((step, index) => {\n          if (placement !== step || flipOrder.length === index + 1) {\n              return data;\n          }\n  \n          placement = data.placement.split('-')[0];\n          placementOpposite = getOppositePlacement(placement);\n  \n          const popperOffsets = getClientRect(data.offsets.popper);\n          const refOffsets = data.offsets.reference;\n  \n          // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n          const overlapsRef = placement === 'left' && Math.floor(popperOffsets.right) > Math.floor(refOffsets.left) || placement === 'right' && Math.floor(popperOffsets.left) < Math.floor(refOffsets.right) || placement === 'top' && Math.floor(popperOffsets.bottom) > Math.floor(refOffsets.top) || placement === 'bottom' && Math.floor(popperOffsets.top) < Math.floor(refOffsets.bottom);\n  \n          const overflowsBoundaries = placement === 'left' && Math.floor(popperOffsets.left) < Math.floor(boundaries.left) || placement === 'right' && Math.floor(popperOffsets.right) > Math.floor(boundaries.right) || placement === 'top' && Math.floor(popperOffsets.top) < Math.floor(boundaries.top) || placement === 'bottom' && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom);\n  \n          // flip the variation if required\n          const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n          const flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && Math.floor(popperOffsets.left) < Math.floor(boundaries.left) || isVertical && variation === 'end' && Math.floor(popperOffsets.right) > Math.floor(boundaries.right) || !isVertical && variation === 'start' && Math.floor(popperOffsets.top) < Math.floor(boundaries.top) || !isVertical && variation === 'end' && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom));\n  \n          if (overlapsRef || overflowsBoundaries || flippedVariation) {\n              // this boolean to detect any flip loop\n              data.flipped = true;\n  \n              if (overlapsRef || overflowsBoundaries) {\n                  placement = flipOrder[index + 1];\n              }\n  \n              if (flippedVariation) {\n                  variation = getOppositeVariation(variation);\n              }\n  \n              data.placement = placement + (variation ? '-' + variation : '');\n              data.offsets.popper = getPopperOffsets(data.instance.state, data.instance.popper, data.offsets.reference, data.placement);\n  \n              data = runModifiers(data.instance.modifiers, data, 'flip');\n          }\n      });\n      return data;\n  }\n  \n  /**\n   * Modifier used to make sure the popper is always near its reference element\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function keepTogether(data) {\n      const popper = getClientRect(data.offsets.popper);\n      const reference = data.offsets.reference;\n      const placement = data.placement.split('-')[0];\n      const floor = Math.floor;\n  \n      if (['top', 'bottom'].indexOf(placement) !== -1) {\n          if (popper.right < floor(reference.left)) {\n              data.offsets.popper.left = floor(reference.left) - popper.width;\n          }\n          if (popper.left > floor(reference.right)) {\n              data.offsets.popper.left = floor(reference.right);\n          }\n      } else {\n          if (popper.bottom < floor(reference.top)) {\n              data.offsets.popper.top = floor(reference.top) - popper.height;\n          }\n          if (popper.top > floor(reference.bottom)) {\n              data.offsets.popper.top = floor(reference.bottom);\n          }\n      }\n  \n      return data;\n  }\n  \n  /**\n   * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n   * The offsets will shift the popper on the side of its reference element.\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   *      Basic usage allows a number used to nudge the popper by the given amount of pixels.\n   *      You can pass a percentage value as string (eg. `20%`) to nudge by the given percentage (relative to reference element size)\n   *      Other supported units are `vh` and `vw` (relative to viewport)\n   *      Additionally, you can pass a pair of values (eg. `10 20` or `2vh 20%`) to nudge the popper\n   *      on both axis.\n   *      A note about percentage values, if you want to refer a percentage to the popper size instead of the reference element size,\n   *      use `%p` instead of `%` (eg: `20%p`). To make it clearer, you can replace `%` with `%r` and use eg.`10%p 25%r`.\n   *      > **Heads up!** The order of the axis is relative to the popper placement: `bottom` or `top` are `X,Y`, the other are `Y,X`\n   * @returns {Object} The data object, properly modified\n   */\n  function offset(data, options) {\n      const placement = data.placement;\n      const popper = data.offsets.popper;\n  \n      let offsets;\n      if (isNumeric(options.offset)) {\n          offsets = [options.offset, 0];\n      } else {\n          // split the offset in case we are providing a pair of offsets separated\n          // by a blank space\n          offsets = options.offset.split(' ');\n  \n          // itherate through each offset to compute them in case they are percentages\n          offsets = offsets.map((offset, index) => {\n              // separate value from unit\n              const split = offset.match(/(\\d*\\.?\\d*)(.*)/);\n              const value = +split[1];\n              const unit = split[2];\n  \n              // use height if placement is left or right and index is 0 otherwise use width\n              // in this way the first offset will use an axis and the second one\n              // will use the other one\n              let useHeight = placement.indexOf('right') !== -1 || placement.indexOf('left') !== -1;\n  \n              if (index === 1) {\n                  useHeight = !useHeight;\n              }\n  \n              const measurement = useHeight ? 'height' : 'width';\n  \n              // if is a percentage, we calculate the value of it using as base the\n              // sizes of the reference element\n              if (unit === '%' || unit === '%r') {\n                  const referenceRect = getClientRect(data.offsets.reference);\n                  let len = referenceRect[measurement];\n                  return len / 100 * value;\n              }\n              // if is a percentage relative to the popper, we calculate the value of it using\n              // as base the sizes of the popper\n              else if (unit === '%p') {\n                      const popperRect = getClientRect(data.offsets.popper);\n                      let len = popperRect[measurement];\n                      return len / 100 * value;\n                  }\n                  // if is a vh or vw, we calculate the size based on the viewport\n                  else if (unit === 'vh' || unit === 'vw') {\n                          let size;\n                          if (unit === 'vh') {\n                              size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                          } else {\n                              size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                          }\n                          return size / 100 * value;\n                      }\n                      // if is an explicit pixel unit, we get rid of the unit and keep the value\n                      else if (unit === 'px') {\n                              return +value;\n                          }\n                          // if is an implicit unit, it's px, and we return just the value\n                          else {\n                                  return +offset;\n                              }\n          });\n      }\n  \n      if (data.placement.indexOf('left') !== -1) {\n          popper.top += offsets[0];\n          popper.left -= offsets[1] || 0;\n      } else if (data.placement.indexOf('right') !== -1) {\n          popper.top += offsets[0];\n          popper.left += offsets[1] || 0;\n      } else if (data.placement.indexOf('top') !== -1) {\n          popper.left += offsets[0];\n          popper.top -= offsets[1] || 0;\n      } else if (data.placement.indexOf('bottom') !== -1) {\n          popper.left += offsets[0];\n          popper.top += offsets[1] || 0;\n      }\n      return data;\n  }\n  \n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries. We can\n   * say it has \"escaped the boundaries\" — or just \"escaped\". In this case we need to\n   * decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should be ignore the boundary and \"escape with the reference\"\n   *\n   * When `escapeWithReference` is `true`, and reference is completely outside the\n   * boundaries, the popper will overflow (or completely leave) the boundaries in order\n   * to remain attached to the edge of the reference.\n   *\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function preventOverflow(data, options) {\n      const boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n      const boundaries = getBoundaries(data.instance.popper, options.padding, boundariesElement);\n      options.boundaries = boundaries;\n  \n      const order = options.priority;\n      let popper = getClientRect(data.offsets.popper);\n  \n      const check = {\n          left() {\n              let left = popper.left;\n              if (popper.left < boundaries.left && !shouldOverflowBoundary(data, options, 'left')) {\n                  left = Math.max(popper.left, boundaries.left);\n              }\n              return { left };\n          },\n          right() {\n              let left = popper.left;\n              if (popper.right > boundaries.right && !shouldOverflowBoundary(data, options, 'right')) {\n                  left = Math.min(popper.left, boundaries.right - popper.width);\n              }\n              return { left };\n          },\n          top() {\n              let top = popper.top;\n              if (popper.top < boundaries.top && !shouldOverflowBoundary(data, options, 'top')) {\n                  top = Math.max(popper.top, boundaries.top);\n              }\n              return { top };\n          },\n          bottom() {\n              let top = popper.top;\n              if (popper.bottom > boundaries.bottom && !shouldOverflowBoundary(data, options, 'bottom')) {\n                  top = Math.min(popper.top, boundaries.bottom - popper.height);\n              }\n              return { top };\n          }\n      };\n  \n      order.forEach(direction => {\n          popper = _extends({}, popper, check[direction]());\n      });\n  \n      data.offsets.popper = popper;\n  \n      return data;\n  }\n  \n  /**\n   * Determine if the popper should overflow a boundary edge to stay together with the reference.\n   */\n  function shouldOverflowBoundary(data, options, overflowDirection) {\n      if (!options.escapeWithReference) {\n          return false;\n      }\n  \n      if (data.flipped && isSameAxis(data.originalPlacement, overflowDirection)) {\n          return true;\n      }\n  \n      if (!isSameAxis(data.originalPlacement, overflowDirection)) {\n          return true;\n      }\n  \n      return true;\n  }\n  \n  /**\n   * Determine if two placement values are on the same axis.\n   */\n  function isSameAxis(a, b) {\n      // placement syntax:\n      //\n      //     ( \"top\" | \"right\" | \"bottom\" | \"left\" ) ( \"-start\" | \"\" | \"-end\" )\n      //     |------------- Direction -------------|\n      //\n      const aDirection = a.split('-')[0];\n      const bDirection = b.split('-')[0];\n  \n      return aDirection === bDirection || aDirection === getOppositePlacement(b);\n  }\n  \n  /**\n   * Modifier used to shift the popper on the start or end of its reference element side\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function shift(data) {\n      const placement = data.placement;\n      const basePlacement = placement.split('-')[0];\n      const shiftvariation = placement.split('-')[1];\n  \n      // if shift shiftvariation is specified, run the modifier\n      if (shiftvariation) {\n          const reference = data.offsets.reference;\n          const popper = getClientRect(data.offsets.popper);\n  \n          const shiftOffsets = {\n              y: {\n                  start: { top: reference.top },\n                  end: { top: reference.top + reference.height - popper.height }\n              },\n              x: {\n                  start: { left: reference.left },\n                  end: { left: reference.left + reference.width - popper.width }\n              }\n          };\n  \n          const axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n  \n          data.offsets.popper = _extends({}, popper, shiftOffsets[axis][shiftvariation]);\n      }\n  \n      return data;\n  }\n  \n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set an x-hidden attribute which can be used to hide\n   * the popper when its reference is out of boundaries.\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function hide(data) {\n      if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n          console.warn('WARNING: preventOverflow modifier is required by hide modifier in order to work, be sure to include it before hide!');\n          return data;\n      }\n  \n      const refRect = data.offsets.reference;\n      const bound = findIndex$1(data.instance.modifiers, modifier => modifier.name === 'preventOverflow').boundaries;\n  \n      if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n          // Avoid unnecessary DOM access if visibility hasn't changed\n          if (data.hide === true) {\n              return data;\n          }\n  \n          data.hide = true;\n          data.attributes['x-out-of-boundaries'] = '';\n      } else {\n          // Avoid unnecessary DOM access if visibility hasn't changed\n          if (data.hide === false) {\n              return data;\n          }\n  \n          data.hide = false;\n          data.attributes['x-out-of-boundaries'] = false;\n      }\n  \n      return data;\n  }\n  \n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @method\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function inner(data) {\n      const placement = data.placement;\n      const basePlacement = placement.split('-')[0];\n      const popper = getClientRect(data.offsets.popper);\n      const reference = getClientRect(data.offsets.reference);\n      const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n  \n      const subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n  \n      popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n  \n      data.placement = getOppositePlacement(placement);\n      data.offsets.popper = getClientRect(popper);\n  \n      return data;\n  }\n  \n  /**\n   * Modifiers are plugins used to alter the behavior of your poppers.\n   * Popper.js uses a set of 7 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Each modifier is an object containing several properties listed below.\n   * @namespace Modifiers\n   * @param {Object} modifier - Modifier descriptor\n   * @param {Integer} modifier.order\n   *      The `order` property defines the execution order of the modifiers.\n   *      The built-in modifiers have orders with a gap of 100 units in between,\n   *      this allows you to inject additional modifiers between the existing ones\n   *      without having to redefine the order of all of them.\n   *      The modifiers are executed starting from the one with the lowest order.\n   * @param {Boolean} modifier.enabled - When `true`, the modifier will be used.\n   * @param {Modifiers~modifier} modifier.function - Modifier function.\n   * @param {Modifiers~onLoad} modifier.onLoad - Function executed on popper initalization\n   * @return {Object} data - Each modifier must return the modified `data` object.\n   */\n  var modifiers = {\n      shift: {\n          order: 100,\n          enabled: true,\n          function: shift\n      },\n      offset: {\n          order: 200,\n          enabled: true,\n          function: offset,\n          // nudges popper from its origin by the given amount of pixels (can be negative)\n          offset: 0\n      },\n      preventOverflow: {\n          order: 300,\n          enabled: true,\n          function: preventOverflow,\n          // popper will try to prevent overflow following these priorities\n          //  by default, then, it could overflow on the left and on top of the boundariesElement\n          priority: ['left', 'right', 'top', 'bottom'],\n          // amount of pixel used to define a minimum distance between the boundaries and the popper\n          // this makes sure the popper has always a little padding between the edges of its container\n          padding: 5,\n          boundariesElement: 'scrollParent'\n      },\n      keepTogether: {\n          order: 400,\n          enabled: true,\n          function: keepTogether\n      },\n      arrow: {\n          order: 500,\n          enabled: true,\n          function: arrow,\n          // selector or node used as arrow\n          element: '[x-arrow]'\n      },\n      flip: {\n          order: 600,\n          enabled: true,\n          function: flip,\n          // the behavior used to change the popper's placement\n          behavior: 'flip',\n          // the popper will flip if it hits the edges of the boundariesElement - padding\n          padding: 5,\n          boundariesElement: 'viewport'\n      },\n      inner: {\n          order: 700,\n          enabled: false,\n          function: inner\n      },\n      hide: {\n          order: 800,\n          enabled: true,\n          function: hide\n      },\n      applyStyle: {\n          order: 900,\n          enabled: true,\n          // if true, it uses the CSS 3d transformation to position the popper\n          gpuAcceleration: true,\n          function: applyStyle,\n          onLoad: applyStyleOnLoad\n      }\n  };\n  \n  /**\n   * Modifiers can edit the `data` object to change the beheavior of the popper.\n   * This object contains all the informations used by Popper.js to compute the\n   * popper position.\n   * The modifier can edit the data as needed, and then `return` it as result.\n   *\n   * @callback Modifiers~modifier\n   * @param {dataObject} data\n   * @return {dataObject} modified data\n   */\n  \n  /**\n   * The `dataObject` is an object containing all the informations used by Popper.js\n   * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arro] `top` and `left` offsets, only one of them will be different from 0\n   */\n  \n  // Utils\n  // Modifiers\n  // default options\n  const DEFAULTS = {\n      // placement of the popper\n      placement: 'bottom',\n  \n      // whether events (resize, scroll) are initially enabled\n      eventsEnabled: true,\n  \n      /**\n       * Callback called when the popper is created.\n       * By default, is set to no-op.\n       * Access Popper.js instance with `data.instance`.\n       * @callback createCallback\n       * @static\n       * @param {dataObject} data\n       */\n      onCreate: () => {},\n  \n      /**\n       * Callback called when the popper is updated, this callback is not called\n       * on the initialization/creation of the popper, but only on subsequent\n       * updates.\n       * By default, is set to no-op.\n       * Access Popper.js instance with `data.instance`.\n       * @callback updateCallback\n       * @static\n       * @param {dataObject} data\n       */\n      onUpdate: () => {},\n  \n      // list of functions used to modify the offsets before they are applied to the popper\n      modifiers\n  };\n  \n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options\n   * @param {String} options.placement=bottom\n   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n   *      left(-start, -end)`\n   *\n   * @param {Boolean} options.eventsEnabled=true\n   *      Whether events (resize, scroll) are initially enabled\n   * @param {Boolean} options.gpuAcceleration=true\n   *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n   *      browser to use the GPU to accelerate the rendering.\n   *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n   *\n   * @param {Boolean} options.removeOnDestroy=false\n   *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n   *\n   * @param {Object} options.modifiers\n   *      List of functions used to modify the data before they are applied to the popper (see source code for default values)\n   *\n   * @param {Object} options.modifiers.arrow - Arrow modifier configuration\n   * @param {String|HTMLElement} options.modifiers.arrow.element='[x-arrow]'\n   *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n   *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n   *      reference element.\n   *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n   *\n   * @param {Object} options.modifiers.offset - Offset modifier configuration\n   * @param {Number} options.modifiers.offset.offset=0\n   *      Amount of pixels the popper will be shifted (can be negative).\n   *\n   * @param {Object} options.modifiers.preventOverflow - PreventOverflow modifier configuration\n   * @param {Array} [options.modifiers.preventOverflow.priority=['left', 'right', 'top', 'bottom']]\n   *      Priority used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n   *      this means that the last one will never overflow\n   * @param {String|HTMLElement} options.modifiers.preventOverflow.boundariesElement='scrollParent'\n   *      Boundaries used by the modifier, can be `scrollParent`, `window`, `viewport` or any DOM element.\n   * @param {Number} options.modifiers.preventOverflow.padding=5\n   *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n   *      this makes sure the popper has always a little padding between the edges of its container.\n   *\n   * @param {Object} options.modifiers.flip - Flip modifier configuration\n   * @param {String|Array} options.modifiers.flip.behavior='flip'\n   *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n   *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n   *      its axis (`right - left`, `top - bottom`).\n   *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n   *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n   *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n   * @param {String|HTMLElement} options.modifiers.flip.boundariesElement='viewport'\n   *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n   *      of the defined boundaries (except if `keepTogether` is enabled)\n   *\n   * @param {Object} options.modifiers.inner - Inner modifier configuration\n   * @param {Number} options.modifiers.innner.enabled=false\n   *      Set to `true` to make the popper flow toward the inner of the reference element.\n   *\n   * @param {Number} options.modifiers.flip.padding=5\n   *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n   *      this makes sure the popper has always a little padding between the edges of its container.\n   *\n   * @param {createCallback} options.onCreate - onCreate callback\n   *      Function called after the Popper has been instantiated.\n   *\n   * @param {updateCallback} options.onUpdate - onUpdate callback\n   *      Function called on subsequent updates of Popper.\n   *\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  class Popper {\n      constructor(reference, popper, options = {}) {\n          this.scheduleUpdate = () => requestAnimationFrame(this.update);\n  \n          // make update() debounced, so that it only runs at most once-per-tick\n          this.update = debounce(this.update.bind(this));\n  \n          // with {} we create a new object with the options inside it\n          this.options = _extends({}, Popper.Defaults, options);\n  \n          // init state\n          this.state = {\n              isDestroyed: false,\n              isCreated: false\n          };\n  \n          // get reference and popper elements (allow jQuery wrappers)\n          this.reference = reference.jquery ? reference[0] : reference;\n          this.popper = popper.jquery ? popper[0] : popper;\n  \n          // refactoring modifiers' list (Object => Array)\n          this.modifiers = Object.keys(Popper.Defaults.modifiers).map(name => _extends({ name }, Popper.Defaults.modifiers[name]));\n  \n          // assign default values to modifiers, making sure to override them with\n          // the ones defined by user\n          this.modifiers = this.modifiers.map(defaultConfig => {\n              const userConfig = options.modifiers && options.modifiers[defaultConfig.name] || {};\n              return _extends({}, defaultConfig, userConfig);\n          });\n  \n          // add custom modifiers to the modifiers list\n          if (options.modifiers) {\n              this.options.modifiers = _extends({}, Popper.Defaults.modifiers, options.modifiers);\n              Object.keys(options.modifiers).forEach(name => {\n                  // take in account only custom modifiers\n                  if (Popper.Defaults.modifiers[name] === undefined) {\n                      const modifier = options.modifiers[name];\n                      modifier.name = name;\n                      this.modifiers.push(modifier);\n                  }\n              });\n          }\n  \n          // get the popper position type\n          this.state.position = getPosition(this.reference);\n  \n          // sort the modifiers by order\n          this.modifiers = this.modifiers.sort((a, b) => a.order - b.order);\n  \n          // modifiers have the ability to execute arbitrary code when Popper.js get inited\n          // such code is executed in the same order of its modifier\n          // they could add new properties to their options configuration\n          // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n          this.modifiers.forEach(modifierOptions => {\n              if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n                  modifierOptions.onLoad(this.reference, this.popper, this.options, modifierOptions, this.state);\n              }\n          });\n  \n          // determine how we should set the origin of offsets\n          this.state.isParentTransformed = isTransformed(this.popper.parentNode);\n  \n          // fire the first update to position the popper in the right place\n          this.update();\n  \n          const eventsEnabled = this.options.eventsEnabled;\n          if (eventsEnabled) {\n              // setup event listeners, they will take care of update the position in specific situations\n              this.enableEventListeners();\n          }\n  \n          this.state.eventsEnabled = eventsEnabled;\n      }\n  \n      //\n      // Methods\n      //\n  \n      /**\n       * Updates the position of the popper, computing the new offsets and applying the new style\n       * Prefer `scheduleUpdate` over `update` because of performance reasons\n       * @method\n       * @memberof Popper\n       */\n      update() {\n          // if popper is destroyed, don't perform any further update\n          if (this.state.isDestroyed) {\n              return;\n          }\n  \n          let data = {\n              instance: this,\n              styles: {},\n              attributes: {},\n              flipped: false,\n              offsets: {}\n          };\n  \n          // make sure to apply the popper position before any computation\n          this.state.position = getPosition(this.reference);\n          setStyles(this.popper, { position: this.state.position });\n  \n          // compute reference element offsets\n          data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n  \n          // compute auto placement, store placement inside the data object,\n          // modifiers will be able to edit `placement` if needed\n          // and refer to originalPlacement to know the original value\n          data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper);\n  \n          // store the computed placement inside `originalPlacement`\n          data.originalPlacement = this.options.placement;\n  \n          // compute the popper offsets\n          data.offsets.popper = getPopperOffsets(this.state, this.popper, data.offsets.reference, data.placement);\n  \n          // run the modifiers\n          data = runModifiers(this.modifiers, data);\n  \n          // the first `update` will call `onCreate` callback\n          // the other ones will call `onUpdate` callback\n          if (!this.state.isCreated) {\n              this.state.isCreated = true;\n              this.options.onCreate(data);\n          } else {\n              this.options.onUpdate(data);\n          }\n      }\n  \n      /**\n       * Schedule an update, it will run on the next UI update available\n       * @method\n       * @memberof Popper\n       */\n  \n  \n      /**\n       * Destroy the popper\n       * @method\n       * @memberof Popper\n       */\n      destroy() {\n          this.state.isDestroyed = true;\n  \n          // touch DOM only if `applyStyle` modifier is enabled\n          if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n              this.popper.removeAttribute('x-placement');\n              this.popper.style.left = '';\n              this.popper.style.position = '';\n              this.popper.style.top = '';\n              this.popper.style[getSupportedPropertyName('transform')] = '';\n          }\n  \n          this.disableEventListeners();\n  \n          // remove the popper if user explicity asked for the deletion on destroy\n          // do not use `remove` because IE11 doesn't support it\n          if (this.options.removeOnDestroy) {\n              this.popper.parentNode.removeChild(this.popper);\n          }\n          return this;\n      }\n  \n      /**\n       * it will add resize/scroll events and start recalculating\n       * position of the popper element when they are triggered\n       * @method\n       * @memberof Popper\n       */\n      enableEventListeners() {\n          if (!this.state.eventsEnabled) {\n              this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n          }\n      }\n  \n      /**\n       * it will remove resize/scroll events and won't recalculate\n       * popper position when they are triggered. It also won't trigger onUpdate callback anymore,\n       * unless you call 'update' method manually.\n       * @method\n       * @memberof Popper\n       */\n      disableEventListeners() {\n          if (this.state.eventsEnabled) {\n              window.cancelAnimationFrame(this.scheduleUpdate);\n              this.state = removeEventListeners(this.reference, this.state);\n          }\n      }\n  \n      /**\n       * Collection of utilities useful when writing custom modifiers\n       * @memberof Popper\n       */\n  \n  \n      /**\n       * List of accepted placements to use as values of the `placement` option\n       * @memberof Popper\n       */\n  \n  \n      /**\n       * Default Popper.js options\n       * @memberof Popper\n       */\n  }\n  Popper.Utils = Utils;\n  Popper.placements = ['auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end'];\n  Popper.Defaults = DEFAULTS;\n  \n  return Popper;\n  \n  })));\n  //# sourceMappingURL=popper.js.map"]}